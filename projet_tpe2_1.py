# -*- coding: utf-8 -*-
"""projet_tpe2_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-2XUrf2kYW1ZOz__95du8AV-c7KmJVBm
"""
from rdflib import URIRef, BNode, Literal
from rdflib import Namespace
from rdflib.namespace import CSVW, DC, DCAT, DCTERMS, DOAP, FOAF, ODRL2, ORG, OWL
from rdflib import Graph, URIRef, Literal, BNode
from rdflib.namespace import FOAF, RDF
from rdflib import URIRef, BNode, Literal
from rdflib import Namespace
from rdflib.namespace import CSVW, DC, DCAT, DCTERMS, DOAP, FOAF, ODRL2, ORG, OWL
from rdflib import Graph, URIRef, Literal, BNode
from rdflib.namespace import FOAF, RDF
from rdflib import Graph, RDF, URIRef, Namespace
from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
import numpy as np
import matplotlib.pyplot as plt
import community.community_louvain as community_louvain
import re

"""Le code extrait et affiche les assertions pertinentes d'un graphe RDF, en excluant celles avec des prédicats commençant par "has" ou "is"."""

from rdflib import Graph, RDF, URIRef, Namespace

# Load the RDF data
graph = Graph()

graph.parse("teaching_akg.ttl", format="ttl")

# Define namespace and type for entities (adjust as needed)
TAO = Namespace("http://sonfack.com/2024/01/tao#")  # Replace with your actual namespace

# Extract and print relevant assertions
relevant_assertions = []

for subj, pred, obj in graph:
    # Exclude subjects and predicates starting with "has" or "is"
    if not str(pred).startswith("http://sonfack.com/2024/01/tao#has") and not str(pred).startswith("http://sonfack.com/2024/01/tao#is"):
        relevant_assertions.append((subj, pred, obj))

# Print relevant assertions
for subj, pred, obj in relevant_assertions:
    print(f"Subject: {subj.split('#')[-1]}\nPredicate: {pred.split('#')[-1]}\nObject: {obj.split('#')[-1]}\n" )

"""Les fonctions extraient toutes les activités d'un graphe RDF et récupèrent les informations liées à un nœud spécifique dans le graphe."""

from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt

akg_file = "C://Users//teaching_akg.ttl" # Corrigez l'extension ici

g = Graph()
g.parse(akg_file)
G = nx.DiGraph()
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")


def read_all_activities(akg: Graph, as_str=True) -> list:
    """This function returns all activities of an activity knowledge graph
    - akg: an activity knowledge graph as parsed by RDFLib
    - as_str: (boolean) tells if the activities are simple str default = True
    """
    activities_list = [str(activity) if as_str else activity for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]
    return activities_list


def read_akg_node(node_uri: str, akg:Graph, as_str=True) -> dict:
    """This function returns all elements directly linked to a akg node
    - activity_uri (string): the given activity uri in graph akg
    - akg (Graph): an activity knowledge graph as parsed by RDFLib
    """
    activity_info = {}
    activity_uri_ref = f"{akg_namespace}{node_uri}"
    print(activity_uri_ref)
    for act_predicate, act_object in akg.predicate_objects(subject=URIRef(activity_uri_ref)):
        pred = act_predicate
        obj = act_object
        if as_str:
            pred = str(act_predicate)
            obj = str(act_object)
        if pred in activity_info:
            existing_objects = activity_info[pred] + [obj]
            activity_info[pred] = existing_objects
        else:
            activity_info[pred] = [obj]
    return activity_info

print(read_all_activities(g, False))

"""La fonction `visualize_activity` trace et affiche un graphe NetworkX avec des nœuds, des arêtes et des labels d'arêtes en utilisant `matplotlib`."""

def add_activity_to_nxgraph(G, activity_uri, activity_info):
    #print("ajout de l'activité", activity_uri)
    #print("affichage des informations", activity_info)
    activity_g = nx.DiGraph()

    for pred, obj_list in activity_info.items():
        pred_label = pred.split('/')[-1]
        if '#' in pred_label:
            pred_label = pred_label.split('#')[1]

        for obj in obj_list:
            obj_label = obj.split('/')[-1]
            node_info = read_akg_node(obj_label, g)

            if node_info:
                # Assurez-vous que vous récupérez une chaîne et non une liste
                obj_label = node_info.get('http://sonfack.com/2023/12/tao/hasName', [None])[0]
                if obj_label is None:
                    continue  # Passer à l'itération suivante si obj_label est None


            G.add_node(activity_uri)
            G.add_node(obj_label)
            G.add_edge(activity_uri, obj_label, label=pred_label)
            activity_g.add_node(activity_uri)
            activity_g.add_node(obj_label)
            activity_g.add_edge(activity_uri, obj_label, label=pred_label)

    visualize_activity(activity_g)

def visualize_activity(G):
  # Visualize the graph
  plt.figure(figsize=(12, 12))

  # Generate positions for nodes using a layout algorithm
  pos = nx.spring_layout(G, seed=42)

  # Draw the nodes and edges
  nx.draw(G, pos, with_labels=True, node_size=300, node_color="blue", font_size=5, font_weight="bold", edge_color="black")

  # Draw edge labels
  edge_labels = nx.get_edge_attributes(G, 'label')
  nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='green', font_size=8)

  # Show plot
  plt.title("Graphe de Connaissances des Activités")
  plt.show()

def visualize_activity(G):
  # Visualize the graph
  plt.figure(figsize=(12, 12))

  # Generate positions for nodes using a layout algorithm
  pos = nx.spring_layout(G, seed=42)

  # Draw the nodes and edges
  nx.draw(G, pos, with_labels=True, node_size=300, node_color="blue", font_size=5, font_weight="bold", edge_color="black")

  # Draw edge labels
  edge_labels = nx.get_edge_attributes(G, 'label')
  nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='green', font_size=8)

  # Show plot
  plt.title("Graphe de Connaissances des Activités")
  plt.show()

"""Le code lit des activités à partir d'un graphe, les ajoute à un graphe NetworkX, puis visualise ce graphe avec des nœuds, des arêtes et des labels."""

def add_activity_to_nxgraph(G, activity_uri, activity_info):
    #print("ajout de l'activité", activity_uri)
    #print("affichage des informations", activity_info)
    activity_g = nx.DiGraph()

    for pred, obj_list in activity_info.items():
        pred_label = pred.split('/')[-1]
        if '#' in pred_label:
            pred_label = pred_label.split('#')[1]

        for obj in obj_list:
            obj_label = obj.split('/')[-1]
            node_info = read_akg_node(obj_label, g)

            if node_info:
                # Assurez-vous que vous récupérez une chaîne et non une liste
                obj_label = node_info.get('http://sonfack.com/2023/12/tao/hasName', [None])[0]
                if obj_label is None:
                    continue  # Passer à l'itération suivante si obj_label est None


            G.add_node(activity_uri)
            G.add_node(obj_label)
            G.add_edge(activity_uri, obj_label, label=pred_label)
            activity_g.add_node(activity_uri)
            activity_g.add_node(obj_label)
            activity_g.add_edge(activity_uri, obj_label, label=pred_label)

    visualize_activity(activity_g)

"""Le code crée un graphe dirigé à partir de données RDF, en ajoutant des noeuds et des arêtes pour les assertions pertinentes, puis visualise ce graphe avec des étiquettes pour les relations."""

from rdflib import Graph, Namespace
import networkx as nx
import matplotlib.pyplot as plt
import re

# Load the RDF data
graph = Graph()
graph.parse("C://Users//teaching_akg.ttl", format="ttl")

# Define namespace and type for entities (adjust as needed)
TAO = Namespace("http://sonfack.com/2024/01/tao#")  # Replace with your actual namespace

# Convertir le graphe en non dirigé
G_undirected = G.to_undirected()

# Appliquer l'algorithme de Louvain
partitions = community_louvain.best_partition(G_undirected)

# Afficher le nombre de communautés détectées
print(f"Nombre de communautés détectées: {len(set(partitions.values()))}")

# Visualisation des communautés
# Exemples d'activité et d'informations à ajouter (à ajuster selon vos données)
activity_uri = "http://example.com/activity1"
activity_info = {
    "http://example.com/predicate1": ["http://example.com/object1", "http://example.com/object2"],
    "http://example.com/predicate2": ["http://example.com/object3"]
}

# Appeler la fonction pour ajouter l'activité au graphe
add_activity_to_nxgraph(G, activity_uri, activity_info)
plt.figure(figsize=(22, 22))
pos = nx.spring_layout(G_undirected, seed=42)
cmap = plt.get_cmap('viridis')
nx.draw_networkx_nodes(G_undirected, pos, node_size=300, node_color=list(partitions.values()), cmap=cmap, alpha=1)
nx.draw_networkx_edges(G_undirected, pos, edge_color="black", alpha=1)
nx.draw_networkx_labels(G_undirected, pos, font_size=8)
plt.title("Détection de Communautés")
plt.show()

import community
print(community.__file__)

def read_all_activities(akg: Graph, as_str=True) -> list:
    """Retourne toutes les activités d'un graphe de connaissances."""
    activities_list = [str(activity) if as_str else activity for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]
    return activities_list

def read_akg_node(node_uri: str, akg: Graph, as_str=True) -> dict:
    """Retourne tous les éléments directement liés à un nœud du graphe."""
    activity_info = {}
    activity_uri_ref = f"{akg_namespace}{node_uri}"
    for act_predicate, act_object in akg.predicate_objects(subject=URIRef(activity_uri_ref)):
        pred = act_predicate
        obj = act_object
        if as_str:
            pred = str(act_predicate)
            obj = str(act_object)
        if pred in activity_info:
            existing_objects = activity_info[pred] + [obj]
            activity_info[pred] = existing_objects
        else:
            activity_info[pred] = [obj]
    return activity_info

def add_activity_to_nxgraph(G, activity_uri, activity_info):
    """Ajoute les activités et leurs relations au graphe NetworkX."""
    for pred, obj_list in activity_info.items():
        pred_label = pred.split('/')[-1]
        if '#' in pred_label:
            pred_label = pred_label.split('#')[1]

        for obj in obj_list:
            obj_label = obj.split('/')[-1]
            node_info = read_akg_node(obj_label, graph)

            if node_info:
                # Assurez-vous que vous récupérez une chaîne et non une liste
                obj_label = node_info.get('http://sonfack.com/2023/12/tao/hasName', [None])[0]
                if obj_label is None:
                    continue

            G.add_node(activity_uri)
            G.add_node(obj_label)
            G.add_edge(activity_uri, obj_label, label=pred_label)

def visualize_activity(G):
    """Visualiser le graphe de connaissances."""
    plt.figure(figsize=(12, 12))
    pos = nx.spring_layout(G, seed=42)
    nx.draw(G, pos, with_labels=True, node_size=300, node_color="blue", font_size=5, font_weight="bold", edge_color="black")
    edge_labels = nx.get_edge_attributes(G, 'label')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='green', font_size=8)
    plt.title("Graphe de Connaissances des Activités")
    plt.show()

# Charger le fichier RDF dans un graphe NetworkX
G = nx.DiGraph()

# Lire toutes les activités
liste_activity = read_all_activities(graph, as_str=True)

# Ajouter chaque activité au graphe
for activity in liste_activity:
    subj = activity.split('/')[-1]
    info_activity = read_akg_node(subj, graph, as_str=True)
    add_activity_to_nxgraph(G, activity, info_activity)

# Détection des communautés
partition = community_louvain.best_partition(G.to_undirected())

# Visualiser les communautés
plt.figure(figsize=(12, 12))
pos = nx.spring_layout(G, seed=42)
colors = [partition[node] for node in G.nodes()]
nx.draw(G, pos, node_color=colors, with_labels=True, node_size=300, cmap=plt.cm.jet, font_size=5, font_weight="bold", edge_color="black")
edge_labels = nx.get_edge_attributes(G, 'label')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red', font_size=10)
plt.title("Communautés dans le Graphe de Connaissances des Activités")
plt.show()

"""vérification du nombres de noeuds et d'arêtes"""

# Initialiser un graphe orienté
G = nx.DiGraph()
# Exemples d'activité et d'informations à ajouter (à ajuster selon vos données)
activity_uri = "http://example.com/activity1"
activity_info = {
    "http://example.com/predicate1": ["http://example.com/object1", "http://example.com/object2"],
    "http://example.com/predicate2": ["http://example.com/object3"]
}


# Parcourez le graphe RDF et ajoutez les nœuds et arêtes dans G
for subj, pred, obj in graph:
    if not str(pred).startswith("http://sonfack.com/2024/01/tao#has") and not str(pred).startswith("http://sonfack.com/2024/01/tao#is"):
        subj_label = subj.split('#')[-1]
        pred_label = pred.split('#')[-1]
        obj_label = obj.split('#')[-1]
        G.add_node(subj_label)  # Ajouter un nœud pour le sujet
        G.add_node(obj_label)   # Ajouter un nœud pour l'objet
        G.add_edge(subj_label, obj_label, label=pred_label)  # Ajouter une arête avec le prédicat comme étiquette

print(f"Nombre de nœuds : {G.number_of_nodes()}")
print(f"Nombre d'arêtes : {G.number_of_edges()}")

import networkx as nx
import matplotlib.pyplot as plt
from networkx.algorithms import community

def visualize_individual_communities(G, partition):
    """Visualiser chaque communauté du graphe de connaissances séparément."""
    communities = {}
    for node, community_id in partition.items():
        if community_id not in communities:
            communities[community_id] = []
        communities[community_id].append(node)

    for community_id, nodes in communities.items():
        subgraph = G.subgraph(nodes)
        plt.figure(figsize=(8, 8))
        pos = nx.spring_layout(subgraph, seed=42)
        nx.draw(subgraph, pos, with_labels=True, node_size=300, node_color="skyblue", font_size=8, font_weight="bold", edge_color="gray")
        edge_labels = nx.get_edge_attributes(subgraph, 'label')
        nx.draw_networkx_edge_labels(subgraph, pos, edge_labels=edge_labels, font_color='red', font_size=10)
        plt.title(f"Communauté {community_id} dans le Graphe de Connaissances")
        plt.show()

# Charger le fichier RDF dans un graphe NetworkX
G = nx.DiGraph()

# Lire toutes les activités
liste_activity = read_all_activities(graph, as_str=True)

# Ajouter chaque activité au graphe
for activity in liste_activity:
    subj = activity.split('/')[-1]
    info_activity = read_akg_node(subj, graph, as_str=True)
    add_activity_to_nxgraph(G, activity, info_activity)

# Détection des communautés avec networkx
partition = community.greedy_modularity_communities(G.to_undirected())

# Convertir le résultat en un format compatible avec visualize_individual_communities
partition_dict = {}
for i, comm in enumerate(partition):
    for node in comm:
        partition_dict[node] = i

# Visualiser chaque communauté séparément
visualize_individual_communities(G, partition_dict)

from rdflib import Graph, RDF, URIRef, Namespace
import networkx as nx
import matplotlib.pyplot as plt
import community.community_louvain as community_louvain  # Correct import



# Définir les espaces de noms
TAO = Namespace("http://sonfack.com/2024/01/tao#")  # Remplacez par votre espace de nom réel
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")

def read_all_activities(akg: Graph, as_str=True) -> list:
    """Retourne toutes les activités d'un graphe de connaissances."""
    activities_list = [str(activity) if as_str else activity for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]
    return activities_list

def read_akg_node(node_uri: str, akg: Graph, as_str=True) -> dict:
    """Retourne tous les éléments directement liés à un nœud du graphe."""
    activity_info = {}
    activity_uri_ref = f"{akg_namespace}{node_uri}"
    for act_predicate, act_object in akg.predicate_objects(subject=URIRef(activity_uri_ref)):
        pred = act_predicate
        obj = act_object
        if as_str:
            pred = str(act_predicate)
            obj = str(act_object)
        if pred in activity_info:
            existing_objects = activity_info[pred] + [obj]
            activity_info[pred] = existing_objects
        else:
            activity_info[pred] = [obj]
    return activity_info

def get_clean_name(uri):
    """Nettoie l'URI pour ne garder que la partie nom sans l'URI et sans l'ID éventuel."""
    return uri.split('/')[-1].split('-')[0]

def add_activity_to_nxgraph(G, activity_uri, activity_info):
    """Ajoute les activités et leurs relations au graphe NetworkX."""
    # Essayer de récupérer le nom (hasName)
    has_name = activity_info.get('http://sonfack.com/2023/12/tao/hasName', [None])[0]
    if has_name:
        central_node = get_clean_name(has_name)  # Utiliser le nom nettoyé
    else:
        central_node = get_clean_name(activity_uri)  # Utiliser l'URI nettoyée si hasName n'existe pas

    for pred, obj_list in activity_info.items():
        pred_label = pred.split('/')[-1]
        if '#' in pred_label:
            pred_label = pred_label.split('#')[1]

        for obj in obj_list:
            obj_label = get_clean_name(obj)  # Nettoyer également les objets
            node_info = read_akg_node(obj_label, graph)

            if node_info:
                obj_label = node_info.get('http://sonfack.com/2023/12/tao/hasName', [None])[0]
                if obj_label is None:
                    continue
                obj_label = get_clean_name(obj_label)

            G.add_node(central_node)
            G.add_node(obj_label)
            G.add_edge(central_node, obj_label, label=pred_label)

def visualize_individual_communities(G, partition):
    """Visualiser chaque communauté du graphe de connaissances séparément."""
    communities = {}
    for node, community_id in partition.items():
        if community_id not in communities:
            communities[community_id] = []
        communities[community_id].append(node)

    # Afficher le nombre de communautés détectées
    num_communities = len(communities)
    print(f"Nombre de communautés détectées : {num_communities}")

    for community_id, nodes in communities.items():
        subgraph = G.subgraph(nodes)
        plt.figure(figsize=(8, 8))
        pos = nx.spring_layout(subgraph, seed=42)

        # Utiliser des labels pour les nœuds
        node_labels = {node: node for node in subgraph.nodes()}
        nx.draw(subgraph, pos, labels=node_labels, with_labels=True, node_size=300, node_color="skyblue", font_size=8, font_weight="bold", edge_color="gray")

        # Ajouter des étiquettes pour les arêtes
        edge_labels = nx.get_edge_attributes(subgraph, 'label')
        nx.draw_networkx_edge_labels(subgraph, pos, edge_labels=edge_labels, font_color='red', font_size=10)

        # Afficher le titre
        plt.title(f"Communauté {community_id} dans le Graphe de Connaissances")
        plt.show()

# Charger le fichier RDF dans un graphe NetworkX
G = nx.DiGraph()
# Lire toutes les activités
liste_activity = read_all_activities(graph, as_str=True)

# Ajouter chaque activité au graphe
for activity in liste_activity:
    subj = activity.split('/')[-1]
    info_activity = read_akg_node(subj, graph, as_str=True)
    add_activity_to_nxgraph(G, activity, info_activity)

# Détection des communautés
partition = community_louvain.best_partition(G.to_undirected())

# Visualiser chaque communauté séparément et afficher le nombre de communautés
visualize_individual_communities(G, partition)

def visualize_graph_with_communities(G, partition):
    """Visualiser tout le graphe avec les communautés détectées."""
    plt.figure(figsize=(12, 12))

    # Utiliser une palette de couleurs pour les différentes communautés
    community_colors = [f"C{community_id % 10}" for community_id in partition.values()]

    # Positionner les nœuds
    pos = nx.spring_layout(G, seed=42)  # Utiliser le même layout pour avoir une cohérence visuelle

    # Dessiner les nœuds avec les couleurs de la communauté
    nx.draw_networkx_nodes(G, pos, node_color=community_colors, node_size=300, cmap=plt.cm.Set1)

    # Dessiner les arêtes
    nx.draw_networkx_edges(G, pos, edge_color="gray", alpha=0.5)

    # Afficher les labels des nœuds
    node_labels = {node: node for node in G.nodes()}
    nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=8, font_weight="bold", font_color="black")

    # Afficher les labels des arêtes
    edge_labels = nx.get_edge_attributes(G, 'label')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red', font_size=10)

    plt.title("Visualisation des communautés dans le Graphe de Connaissances")
    plt.show()

# Visualiser le graphe entier avec les communautés et les relations entre elles
visualize_graph_with_communities(G, partition)

import matplotlib.pyplot as plt
import networkx as nx

def visualize_communities_separately(G, partition):
    """Visualiser chaque communauté séparément avec une couleur distincte."""

    # Obtenir les communautés uniques
    communities = set(partition.values())

    for community_id in communities:
        # Créer un sous-graphe pour la communauté actuelle
        subgraph_nodes = [node for node, comm in partition.items() if comm == community_id]
        H = G.subgraph(subgraph_nodes)

        # Positionner les nœuds
        pos = nx.spring_layout(H, seed=42)

        plt.figure(figsize=(10, 8))

        # Dessiner les nœuds avec une couleur spécifique à la communauté
        nx.draw_networkx_nodes(H, pos, node_color=f"C{community_id % 10}", node_size=300, cmap=plt.cm.Set1)

        # Dessiner les arêtes
        nx.draw_networkx_edges(H, pos, edge_color="gray", alpha=0.5)

        # Afficher les labels des nœuds
        node_labels = {node: node for node in H.nodes()}
        nx.draw_networkx_labels(H, pos, labels=node_labels, font_size=8, font_weight="bold", font_color="black")

        # Afficher les labels des arêtes
        edge_labels = nx.get_edge_attributes(H, 'label')
        nx.draw_networkx_edge_labels(H, pos, edge_labels=edge_labels, font_color='red', font_size=10)

        plt.title(f"Communauté {community_id} dans le Graphe de Connaissances")
        plt.show()

# Visualiser chaque communauté séparément
visualize_communities_separately(G, partition)

# Charger le fichier RDF dans un graphe NetworkX
G = nx.DiGraph()

# Lire toutes les activités
liste_activity = read_all_activities(graph, as_str=True)

# Afficher le nombre total d'activités extraites
print(f"Nombre total d'activités extraites : {len(liste_activity)}")

# Ajouter chaque activité au graphe
for activity in liste_activity:
    subj = activity.split('/')[-1]
    info_activity = read_akg_node(subj, graph, as_str=True)
    add_activity_to_nxgraph(G, activity, info_activity)

# Détection des communautés
partition = community_louvain.best_partition(G.to_undirected())

# Afficher le nombre total de communautés détectées
num_communities = len(set(partition.values()))
print(f"Nombre total de communautés détectées : {num_communities}")

"""lister les activités"""

from rdflib import Graph, RDF, Namespace

# Assurez-vous d'avoir défini les namespaces appropriés
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")
tao_namespace = Namespace("http://sonfack.com/2023/12/tao/")

def get_all_activities(akg: Graph) -> list:
    """Retourne une liste de toutes les activités dans le graphe RDF."""
    activities = [str(activity) for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]
    return activities


all_activities = get_all_activities(graph)
print("Liste de toutes les activités :")
for activity in all_activities:
    subj = activity.split('/')[-1]
    info_activity = read_akg_node(subj, graph, as_str=True)
    add_activity_to_nxgraph(G, activity, info_activity)
    print(activity)

from rdflib import Graph, RDF, Namespace
import re

# Assurez-vous d'avoir défini les namespaces appropriés
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")
tao_namespace = Namespace("http://sonfack.com/2023/12/tao/")

def get_all_activities(akg: Graph) -> list:
    """Retourne une liste de toutes les activités dans le graphe RDF."""
    activities = [str(activity) for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]
    return activities

def extract_name_without_identifiers(uri: str, namespace: str) -> str:
    """Extrait le nom de l'activité sans les identifiants de l'URI après le namespace."""
    match = re.match(f"{re.escape(namespace)}(.+?)(?:[-_].*)?$", uri)
    if match:
        name_without_identifiers = match.group(1).replace('-', ' ').replace('_', ' ').title()
        return name_without_identifiers
    return uri

# Récupérer et afficher les noms des activités
all_activities = get_all_activities(graph)
print("Liste de toutes les activités :")
for activity in all_activities:
    activity_name = extract_name_without_identifiers(activity, "http://sonfack.com/2023/12/tao/")
    print(activity_name)

"""détailles sur l'activités"""

from rdflib import Graph, RDF, Namespace
import re

# Assurez-vous d'avoir défini les namespaces appropriés
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")
tao_namespace = Namespace("http://sonfack.com/2023/12/tao/")

def get_all_activities(akg: Graph) -> list:
    """Retourne une liste de toutes les activités dans le graphe RDF."""
    activities = [str(activity) for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]
    return activities

def extract_name_without_identifiers(uri: str, namespace: str) -> str:
    """Extrait le nom de l'activité sans les identifiants de l'URI après le namespace."""
    match = re.match(f"{re.escape(namespace)}(.+?)(?:[-_].*)?$", uri)
    if match:
        name_without_identifiers = match.group(1).replace('-', ' ').replace('_', ' ').title()
        return name_without_identifiers
    return uri

def get_activity_details(graph: Graph, activity_uri: str) -> dict:
    """Retourne les détails d'une activité spécifique en fonction de son URI complète."""
    details = {}
    for subj, pred, obj in graph:
        if str(subj) == activity_uri or str(obj) == activity_uri:
            subj_label = extract_name_without_identifiers(str(subj), "http://sonfack.com/2023/12/tao/")
            pred_label = pred.split('#')[-1]  # Extrait la partie du prédicat après le '#'
            obj_label = extract_name_without_identifiers(str(obj), "http://sonfack.com/2023/12/tao/")

            if subj_label not in details:
                details[subj_label] = []

            # Ajouter les détails comme tuple (prédicat, objet)
            details[subj_label].append((pred_label, obj_label))
    return details

"""filtrage"""

# Récupérer et afficher les noms des activités
all_activities = get_all_activities(graph)
print("Liste de toutes les activités :")
for activity in all_activities:
    activity_name = extract_name_without_identifiers(activity, "http://sonfack.com/2023/12/tao/")
    print(f"Nom de l'activité: {activity_name}")

    # Obtenir les détails de l'activité
    activity_details = get_activity_details(graph, activity)

    # Afficher les détails de l'activité
    print("Détails de l'activité :")
    for subj, details in activity_details.items():
        print(f"  Activité: {subj}")
        for pred, obj in details:
            print(f"    {pred}: {obj}")
    print("\n")

"""partie ajouter

"""

# Imports nécessaires
from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt
from community import community_louvain
import re



akg_file = "C://Users//teaching_akg.ttl"  # Chemin du fichier TTL 

# Charger le fichier RDF et initialiser le graphe NetworkX
g = Graph()
g.parse(akg_file)
G = nx.Graph()

# Définir les namespaces
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")

# Fonction pour extraire et nettoyer les noms des URI
def extract_name(uri):
    name = re.sub(r'http://sonfack\.com/2023/12/(tao|cao)/', '', uri)
    name = re.sub(r'-\w+$', '', name)
    return name

# Fonction pour lire toutes les activités
def read_all_activities(akg: Graph) -> list:
    return [activity for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]

# Fonction pour obtenir les détails d'une activité spécifique
def get_activity_details(activity_uri: URIRef, akg: Graph) -> dict:
    details = {}
    for pred, obj in akg.predicate_objects(subject=activity_uri):
        if str(obj) == str(cao_namespace.Activity):  # Ignorer le type 'Activity'
            continue
        pred_label = extract_name(str(pred))
        obj_label = extract_name(str(obj))
        details.setdefault(pred_label, []).append(obj_label)
    return details

# Fonction pour ajouter les activités et leurs relations au graphe NetworkX
def add_activity_to_graph(G, activity_uri, akg, excluded_activity=None):
    details = get_activity_details(activity_uri, akg)
    activity_name = extract_name(str(activity_uri))

    for pred, objs in details.items():
        for obj in objs:
            obj_name = extract_name(str(obj))
            if obj_name != excluded_activity:
                G.add_node(activity_name, type="activité", color="orange")
                G.add_node(obj_name, type="ressource", color="blue")
                G.add_edge(activity_name, obj_name, label=pred)

# Fonction pour appliquer l'algorithme de Louvain et obtenir des partitions
def apply_louvain_clustering(G):
    partition = community_louvain.best_partition(G)
    return partition

# Visualisation du graphe de connaissances avec les communautés détectées
def visualize_louvain_graph(G, partition):
    pos = nx.spring_layout(G, seed=42, k=1.5, scale=2)  # Augmentation de la force d'espacement
    plt.figure(figsize=(14, 12))
    node_colors = ["orange" if G.nodes[node].get("type") == "activité" else "blue" for node in G]
    node_sizes = [1200 if G.nodes[node].get("type") == "activité" else 600 for node in G]
    nx.draw(G, pos, with_labels=True, labels={node: extract_name(node)[:15] + '...' for node in G.nodes()},
            node_size=node_sizes, node_color=node_colors, font_size=9)  # Limiter la longueur des labels
    edge_labels = nx.get_edge_attributes(G, 'label')
    simplified_edge_labels = {key: extract_name(label)[:10] + '...' for key, label in edge_labels.items()}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=simplified_edge_labels, font_color="red")
    plt.legend(handles=[
        plt.Line2D([0], [0], marker='o', color='w', label='Activité', markersize=15, markerfacecolor='orange'),
        plt.Line2D([0], [0], marker='o', color='w', label='Ressource', markersize=15, markerfacecolor='blue')
    ], loc='upper right')
    plt.title("Graphe de connaissances avec détection des communautés (Algorithme de Louvain)")
    plt.show()

# Paramètres et visualisation
all_activities = read_all_activities(g)

# Visualisation des communautés
for activity_uri in all_activities:
    add_activity_to_graph(G, activity_uri, g)
partition = apply_louvain_clustering(G)
visualize_louvain_graph(G, partition)

# Imports nécessaires
from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt
from community import community_louvain
import re



akg_file = "C://Users//teaching_akg.ttl" # Chemin du fichier TTL 

# Charger le fichier RDF et initialiser le graphe NetworkX
g = Graph()
g.parse(akg_file)
G = nx.Graph()

# Définir les namespaces
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")

# Fonction pour extraire et nettoyer les noms des URI
def extract_name(uri):
    name = re.sub(r'http://sonfack\.com/2023/12/(tao|cao)/', '', uri)
    name = re.sub(r'-\w+$', '', name)
    return name

# Fonction pour lire toutes les activités
def read_all_activities(akg: Graph) -> list:
    return [activity for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]

# Fonction pour obtenir les détails d'une activité spécifique
def get_activity_details(activity_uri: URIRef, akg: Graph) -> dict:
    details = {}
    for pred, obj in akg.predicate_objects(subject=activity_uri):
        if str(obj) == str(cao_namespace.Activity):  # Ignorer le type 'Activity'
            continue
        pred_label = extract_name(str(pred))
        obj_label = extract_name(str(obj))
        details.setdefault(pred_label, []).append(obj_label)
    return details

# Fonction pour ajouter les activités et leurs relations au graphe NetworkX
def add_activity_to_graph(G, activity_uri, akg, excluded_activity=None):
    details = get_activity_details(activity_uri, akg)
    activity_name = extract_name(str(activity_uri))

    for pred, objs in details.items():
        for obj in objs:
            obj_name = extract_name(str(obj))
            if obj_name != excluded_activity:
                G.add_node(activity_name, type="activité", color="orange")
                G.add_node(obj_name, type="ressource", color="blue")
                G.add_edge(activity_name, obj_name, label=pred)

# Fonction pour appliquer l'algorithme de Louvain et obtenir des partitions
def apply_louvain_clustering(G):
    partition = community_louvain.best_partition(G)
    return partition

# Visualisation d'un sous-graphe spécifique à une communauté
def visualize_community(G, community_nodes, community_id):
    subgraph = G.subgraph(community_nodes)
    pos = nx.spring_layout(subgraph, seed=42, k=1.5, scale=2)  # Augmentation de l'espacement
    plt.figure(figsize=(12, 10))
    node_colors = ["orange" if subgraph.nodes[node].get("type") == "activité" else "blue" for node in subgraph]
    node_sizes = [1200 if subgraph.nodes[node].get("type") == "activité" else 600 for node in subgraph]
    nx.draw(subgraph, pos, with_labels=True, labels={node: extract_name(node)[:15] + '...' for node in subgraph.nodes()},
            node_size=node_sizes, node_color=node_colors, font_size=9)
    edge_labels = nx.get_edge_attributes(subgraph, 'label')
    simplified_edge_labels = {key: extract_name(label)[:10] + '...' for key, label in edge_labels.items()}
    nx.draw_networkx_edge_labels(subgraph, pos, edge_labels=simplified_edge_labels, font_color="red")
    plt.legend(handles=[
        plt.Line2D([0], [0], marker='o', color='w', label='Activité', markersize=15, markerfacecolor='orange'),
        plt.Line2D([0], [0], marker='o', color='w', label='Ressource', markersize=15, markerfacecolor='blue')
    ], loc='upper right')
    plt.title(f"Graphe de la Communauté {community_id}")
    plt.show()

# Fonction principale pour visualiser chaque communauté séparément
def visualize_all_communities(G, partition):
    communities = {}
    for node, community_id in partition.items():
        communities.setdefault(community_id, []).append(node)

    for community_id, community_nodes in communities.items():
        print(f"Visualisation de la communauté {community_id} avec {len(community_nodes)} nœuds")
        visualize_community(G, community_nodes, community_id)

# Paramètres et visualisation
all_activities = read_all_activities(g)

# Construction du graphe complet
for activity_uri in all_activities:
    add_activity_to_graph(G, activity_uri, g)

# Application de l'algorithme de Louvain
partition = apply_louvain_clustering(G)

# Visualisation de chaque communauté séparément
visualize_all_communities(G, partition)

# Imports nécessaires
from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt
from community import community_louvain
import re



akg_file = "C://Users//teaching_akg.ttl"  # Chemin du fichier TTL

# Charger le fichier RDF et initialiser le graphe NetworkX
g = Graph()
g.parse(akg_file)
G = nx.Graph()

# Définir les namespaces
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")

# Fonction pour extraire et nettoyer les noms des URI
def extract_name(uri):
    name = re.sub(r'http://sonfack\.com/2023/12/(tao|cao)/', '', uri)
    name = re.sub(r'-\w+$', '', name)
    return name

# Fonction pour lire toutes les activités
def read_all_activities(akg: Graph) -> list:
    return [activity for activity in akg.subjects(predicate=RDF.type, object=cao_namespace.Activity, unique=True)]

# Fonction pour obtenir les détails d'une activité spécifique
def get_activity_details(activity_uri: URIRef, akg: Graph) -> dict:
    details = {}
    for pred, obj in akg.predicate_objects(subject=activity_uri):
        if str(obj) == str(cao_namespace.Activity):  # Ignorer le type 'Activity'
            continue
        pred_label = extract_name(str(pred))
        obj_label = extract_name(str(obj))
        details.setdefault(pred_label, []).append(obj_label)
    return details

# Fonction pour ajouter les objets (ressources) et leurs relations au graphe NetworkX
def add_object_to_graph(G, activity_uri, akg):
    details = get_activity_details(activity_uri, akg)

    for pred, objs in details.items():
        for obj in objs:
            obj_name = extract_name(str(obj))
            activity_name = extract_name(str(activity_uri))

            # Ajouter les nœuds et les arêtes en se basant sur les objets
            G.add_node(obj_name, type="ressource", color="blue")
            G.add_node(activity_name, type="activité", color="orange")
            G.add_edge(obj_name, activity_name, label=pred)

# Fonction pour appliquer l'algorithme de Louvain et obtenir des partitions
def apply_louvain_clustering(G):
    partition = community_louvain.best_partition(G)
    return partition

# Visualisation d'un sous-graphe spécifique à une communauté
def visualize_community(G, community_nodes, community_id):
    subgraph = G.subgraph(community_nodes)
    pos = nx.spring_layout(subgraph, seed=42, k=1.5, scale=2)  # Augmentation de l'espacement
    plt.figure(figsize=(12, 10))
    node_colors = ["orange" if subgraph.nodes[node].get("type") == "activité" else "blue" for node in subgraph]
    node_sizes = [1200 if subgraph.nodes[node].get("type") == "activité" else 600 for node in subgraph]
    nx.draw(subgraph, pos, with_labels=True, labels={node: extract_name(node)[:15] + '...' for node in subgraph.nodes()},
            node_size=node_sizes, node_color=node_colors, font_size=9)
    edge_labels = nx.get_edge_attributes(subgraph, 'label')
    simplified_edge_labels = {key: extract_name(label)[:10] + '...' for key, label in edge_labels.items()}
    nx.draw_networkx_edge_labels(subgraph, pos, edge_labels=simplified_edge_labels, font_color="red")
    plt.legend(handles=[
        plt.Line2D([0], [0], marker='o', color='w', label='Activité', markersize=15, markerfacecolor='orange'),
        plt.Line2D([0], [0], marker='o', color='w', label='Ressource', markersize=15, markerfacecolor='blue')
    ], loc='upper right')
    plt.title(f"Graphe de la Communauté {community_id} (basée sur les objets)")
    plt.show()

# Fonction principale pour visualiser chaque communauté séparément
def visualize_all_communities(G, partition):
    communities = {}
    for node, community_id in partition.items():
        communities.setdefault(community_id, []).append(node)

    for community_id, community_nodes in communities.items():
        print(f"Visualisation de la communauté {community_id} avec {len(community_nodes)} nœuds")
        visualize_community(G, community_nodes, community_id)

# Paramètres et visualisation
all_activities = read_all_activities(g)

# Construction du graphe complet en se concentrant sur les objets
for activity_uri in all_activities:
    add_object_to_graph(G, activity_uri, g)

# Application de l'algorithme de Louvain
partition = apply_louvain_clustering(G)

# Visualisation de chaque communauté séparément en fonction des objets
visualize_all_communities(G, partition)

# Imports nécessaires
from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt
from community import community_louvain
import re



akg_file = "C://Users//teaching_akg.ttl"  # Chemin du fichier TTL 

# Charger le fichier RDF et initialiser le graphe NetworkX
g = Graph()
g.parse(akg_file)

# Définir les namespaces
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")

# Liste des propriétés spécifiques pour la détection des communautés
selected_properties = [
    "hasObjective", "activityDescription", "hasSubject", "hasName", "hasDuration",
    "hasBegeinTime", "isComposedOf", "hasLocation", "schema#", "hasBeneficialTo",
    "isCarriedOutWith"
]

# Fonction pour extraire et nettoyer les noms des URI
def extract_name(uri):
    name = re.sub(r'http://sonfack\.com/2023/12/(tao|cao)/', '', uri)
    name = re.sub(r'-\w+$', '', name)
    return name

# Fonction pour obtenir les activités liées à une propriété spécifique
def get_property_graph(akg, property_name):
    G = nx.Graph()
    for subject, pred, obj in akg:
        pred_name = extract_name(str(pred))
        if pred_name == property_name:  # Filtrer par la propriété spécifique
            subject_name = extract_name(str(subject))
            obj_name = extract_name(str(obj))
            G.add_node(subject_name, type="activité", color="orange")
            G.add_node(obj_name, type="ressource", color="blue")
            G.add_edge(subject_name, obj_name, label=pred_name)
    return G

# Fonction pour appliquer l'algorithme de Louvain et obtenir des partitions
def apply_louvain_clustering(G):
    if G.number_of_edges() > 0:  # Vérifier que le graphe a des arêtes
        partition = community_louvain.best_partition(G)
        return partition
    else:
        return {}

# Visualisation d'un sous-graphe spécifique à une propriété avec texte explicatif
def visualize_property_community(G, partition, property_name):
    pos = nx.spring_layout(G, seed=42, k=1.5, scale=2)  # Augmentation de l'espacement
    plt.figure(figsize=(12, 10))
    node_colors = ["orange" if G.nodes[node].get("type") == "activité" else "blue" for node in G]
    node_sizes = [1200 if G.nodes[node].get("type") == "activité" else 600 for node in G]
    nx.draw(G, pos, with_labels=True, labels={node: extract_name(node)[:15] + '...' for node in G.nodes()},
            node_size=node_sizes, node_color=node_colors, font_size=9)
    edge_labels = nx.get_edge_attributes(G, 'label')
    simplified_edge_labels = {key: extract_name(label)[:10] + '...' for key, label in edge_labels.items()}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=simplified_edge_labels, font_color="red")
    plt.legend(handles=[
        plt.Line2D([0], [0], marker='o', color='w', label='Activité', markersize=15, markerfacecolor='orange'),
        plt.Line2D([0], [0], marker='o', color='w', label='Ressource', markersize=15, markerfacecolor='blue')
    ], loc='upper right')
    plt.title(f"Graphe pour la propriété '{property_name}'")
    plt.show()

    # Afficher le texte explicatif pour chaque nœud indiquant sa communauté
    for node, comm_id in partition.items():
        print(f"L'élément '{node}' fait partie de la communauté {comm_id} pour la propriété '{property_name}'.")

# Fonction principale pour visualiser les graphes et les communautés pour chaque propriété spécifique
def visualize_all_properties_communities(akg, properties):
    for property_name in properties:
        print(f"\nVisualisation pour la propriété '{property_name}'")

        # Générer le graphe pour la propriété spécifique
        G = get_property_graph(akg, property_name)

        # Appliquer l'algorithme de Louvain pour détecter les communautés
        partition = apply_louvain_clustering(G)

        # Visualiser le graphe avec les communautés et un texte explicatif
        visualize_property_community(G, partition, property_name)

# Exécuter la visualisation pour toutes les propriétés
visualize_all_properties_communities(g, selected_properties)

# Imports nécessaires
from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt
from community import community_louvain
import re



akg_file = "C://Users//teaching_akg.ttl" # Chemin du fichier TTL 
# Charger le fichier RDF et initialiser le graphe NetworkX
g = Graph()
g.parse(akg_file)

# Définir les namespaces
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")

# Liste des propriétés spécifiques pour la détection des communautés
selected_properties = [
    "hasObjective", "activityDescription", "hasSubject", "hasName", "hasDuration",
    "hasBegeinTime", "isComposedOf", "hasLocation", "schema#", "hasBeneficialTo",
    "isCarriedOutWith"
]

# Fonction pour extraire et nettoyer les noms des URI
def extract_name(uri):
    name = re.sub(r'http://sonfack\.com/2023/12/(tao|cao)/', '', uri)
    name = re.sub(r'-\w+$', '', name)
    return name

# Fonction pour obtenir le graphe centré autour d'un élément pour une propriété spécifique
def get_property_community_graph(akg, property_name):
    G = nx.Graph()
    central_nodes = set()

    # Construire le graphe avec la propriété spécifique
    for subject, pred, obj in akg:
        pred_name = extract_name(str(pred))
        if pred_name == property_name:  # Filtrer par la propriété spécifique
            subject_name = extract_name(str(subject))
            obj_name = extract_name(str(obj))

            # Ajouter le centre et les activités autour
            G.add_node(subject_name, type="activité", color="orange")
            G.add_node(obj_name, type="centre", color="red")  # Centre de la communauté
            G.add_edge(obj_name, subject_name, label=pred_name)

            central_nodes.add(obj_name)

    return G, central_nodes

# Fonction pour appliquer l'algorithme de Louvain et obtenir des partitions
def apply_louvain_clustering(G):
    if G.number_of_edges() > 0:  # Vérifier que le graphe a des arêtes
        partition = community_louvain.best_partition(G)
        return partition
    else:
        return {}

# Visualisation d'une communauté d'activités centrée autour d'un élément pour une propriété donnée
def visualize_community_with_center(G, central_nodes, property_name):
    pos = nx.spring_layout(G, seed=42, k=1.5, scale=2)  # Augmentation de l'espacement
    plt.figure(figsize=(12, 10))
    node_colors = ["red" if node in central_nodes else ("orange" if G.nodes[node].get("type") == "activité" else "blue") for node in G]
    node_sizes = [1400 if node in central_nodes else (1200 if G.nodes[node].get("type") == "activité" else 600) for node in G]
    nx.draw(G, pos, with_labels=True, labels={node: extract_name(node)[:15] + '...' for node in G.nodes()},
            node_size=node_sizes, node_color=node_colors, font_size=9)
    edge_labels = nx.get_edge_attributes(G, 'label')
    simplified_edge_labels = {key: extract_name(label)[:10] + '...' for key, label in edge_labels.items()}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=simplified_edge_labels, font_color="red")
    plt.legend(handles=[
        plt.Line2D([0], [0], marker='o', color='w', label='Centre', markersize=15, markerfacecolor='red'),
        plt.Line2D([0], [0], marker='o', color='w', label='Activité', markersize=15, markerfacecolor='orange'),
        plt.Line2D([0], [0], marker='o', color='w', label='Ressource', markersize=15, markerfacecolor='blue')
    ], loc='upper right')
    plt.title(f"Communauté d'activités pour la propriété '{property_name}'")
    plt.show()

    # Afficher le texte explicatif pour chaque nœud indiquant sa communauté
    for node in central_nodes:
        print(f"L'élément central '{node}' est relié aux activités pour la propriété '{property_name}'.")

# Fonction principale pour visualiser les graphes et les communautés pour chaque propriété spécifique
def visualize_all_property_communities(akg, properties):
    for property_name in properties:
        print(f"\nVisualisation de la communauté pour la propriété '{property_name}'")

        # Générer le graphe pour la propriété spécifique
        G, central_nodes = get_property_community_graph(akg, property_name)

        # Appliquer l'algorithme de Louvain pour détecter les communautés (facultatif ici)
        partition = apply_louvain_clustering(G)

        # Visualiser le graphe avec la communauté centrée et un texte explicatif
        visualize_community_with_center(G, central_nodes, property_name)

# Exécuter la visualisation pour toutes les propriétés
visualize_all_property_communities(g, selected_properties)

# Imports nécessaires
from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt
import re
import numpy as np



akg_file = "C://Users//teaching_akg.ttl" # Chemin du fichier TTL 

# Charger le fichier RDF
g = Graph()
g.parse(akg_file)

# Définir les namespaces
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")

# Liste des propriétés spécifiques pour la détection des communautés
selected_properties = [
    "hasObjective", "activityDescription", "hasSubject", "hasName", "hasDuration",
    "hasBegeinTime", "isComposedOf", "hasLocation", "schema#", "hasBeneficialTo",
    "isCarriedOutWith"
]

# Fonction pour extraire et nettoyer les noms des URI
def extract_name(uri):
    name = re.sub(r'http://sonfack\.com/2023/12/(tao|cao)/', '', uri)
    name = re.sub(r'-\w+$', '', name)
    return name[:12] + '...' if len(name) > 12 else name  # Troncature des noms longs

# Fonction pour créer une représentation en étoile pour une propriété spécifique
def create_star_graph(akg, property_name):
    G = nx.DiGraph()
    center = f"Centre-{property_name}"
    G.add_node(center, color="red")  # Ajouter le centre du graphe

    # Ajouter les activités et ressources liées à la propriété spécifique
    for subject, pred, obj in akg:
        pred_name = extract_name(str(pred))
        if pred_name == property_name:
            subject_name = extract_name(str(subject))
            obj_name = extract_name(str(obj))

            G.add_node(subject_name, color="orange")  # Activité
            G.add_edge(center, subject_name, label=property_name)  # Liaison vers l'activité

            # Ajouter les éléments liés à chaque activité (similaire à votre dessin)
            G.add_node(obj_name, color="blue")  # Élément
            G.add_edge(subject_name, obj_name, label="element")

    return G

# Fonction pour ajuster la disposition et appliquer les distances spécifiées
def custom_layout(G, center_node, activity_distance=15, element_distance=7):
    pos = {}
    pos[center_node] = (0, 0)  # Centre au point d'origine

    # Placer les activités à une distance de 15 unités autour du centre
    activities = [n for n in G.neighbors(center_node)]
    angle_between = 360 / max(len(activities), 1)  # Répartir les activités autour du centre

    for i, activity in enumerate(activities):
        angle_rad = (angle_between * i) * (np.pi / 180)  # Convertir en radians
        pos[activity] = (activity_distance * np.cos(angle_rad), activity_distance * np.sin(angle_rad))

        # Placer les éléments autour de chaque activité à une distance de 7 unités
        elements = list(G.neighbors(activity))
        for j, element in enumerate(elements):
            angle_element = angle_rad + (j + 1) * (np.pi / 180)
            pos[element] = (
                pos[activity][0] + element_distance * np.cos(angle_element),
                pos[activity][1] + element_distance * np.sin(angle_element)
            )

    return pos

# Fonction de visualisation
def visualize_star_graph(G, property_name, center_node):
    pos = custom_layout(G, center_node)
    plt.figure(figsize=(14, 12))
    node_colors = [G.nodes[node].get("color", "gray") for node in G]

    # Dessiner les nœuds et les étiquettes
    nx.draw(G, pos, with_labels=True, node_color=node_colors, font_size=8, node_size=1800)

    # Dessiner les étiquettes des arêtes avec une police plus petite
    edge_labels = nx.get_edge_attributes(G, 'label')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color="red", font_size=6)

    plt.title(f"Communauté d'activités pour la propriété '{property_name}'")
    plt.show()

# Générer et visualiser chaque graphe pour les propriétés spécifiées
for property_name in selected_properties:
    G = create_star_graph(g, property_name)
    center_node = f"Centre-{property_name}"
    visualize_star_graph(G, property_name, center_node)

# Imports nécessaires
from rdflib import Namespace, Graph, URIRef
from rdflib.namespace import RDF
import networkx as nx
import matplotlib.pyplot as plt
import re
import numpy as np



akg_file = "C://Users//teaching_akg.ttl" # Chemin du fichier TTL 

# Charger le fichier RDF
g = Graph()
g.parse(akg_file)

# Définir les namespaces
akg_namespace = Namespace("http://sonfack.com/2023/12/tao/")
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")

# Liste des propriétés spécifiques pour la détection des communautés
selected_properties = [
    "hasObjective", "activityDescription", "hasSubject", "hasName", "hasDuration",
    "hasBegeinTime", "isComposedOf", "hasLocation", "schema#", "hasBeneficialTo",
    "isCarriedOutWith"
]

# Fonction pour extraire et nettoyer les noms des URI
def extract_name(uri):
    name = re.sub(r'http://sonfack\.com/2023/12/(tao|cao)/', '', uri)
    name = re.sub(r'-\w+$', '', name)
    return name[:12] + '...' if len(name) > 12 else name  # Troncature des noms longs

# Fonction pour créer une représentation en étoile pour une propriété spécifique
def create_star_graph(akg, property_name):
    G = nx.DiGraph()
    center = f"Centre-{property_name}"

    # Ajouter les activités et ressources liées à la propriété spécifique
    connections_found = False
    for subject, pred, obj in akg:
        pred_name = extract_name(str(pred))
        if pred_name == property_name:
            subject_name = extract_name(str(subject))
            obj_name = extract_name(str(obj))

            # Ajouter le centre uniquement si des connexions existent
            if not connections_found:
                G.add_node(center, color="red")
                connections_found = True

            G.add_node(subject_name, color="orange")  # Activité
            G.add_edge(center, subject_name, label=property_name)  # Liaison vers l'activité

            G.add_node(obj_name, color="blue")  # Élément
            G.add_edge(subject_name, obj_name, label="element")  # Liaison entre activité et élément

    # Retirer les nœuds isolés sans connexions
    isolated_nodes = [node for node in G.nodes if G.degree(node) == 0]
    G.remove_nodes_from(isolated_nodes)

    return G, connections_found

# Fonction pour ajuster la disposition et appliquer les distances spécifiées
def custom_layout(G, center_node, activity_distance=15, element_distance=7):
    pos = {}
    pos[center_node] = (0, 0)  # Centre au point d'origine

    # Placer les activités à une distance de 15 unités autour du centre
    activities = [n for n in G.neighbors(center_node)]
    angle_between = 360 / max(len(activities), 1)  # Répartir les activités autour du centre

    for i, activity in enumerate(activities):
        angle_rad = (angle_between * i) * (np.pi / 180)  # Convertir en radians
        pos[activity] = (activity_distance * np.cos(angle_rad), activity_distance * np.sin(angle_rad))

        # Placer les éléments autour de chaque activité à une distance de 7 unités
        elements = list(G.neighbors(activity))
        for j, element in enumerate(elements):
            angle_element = angle_rad + (j + 1) * (np.pi / 180)
            pos[element] = (
                pos[activity][0] + element_distance * np.cos(angle_element),
                pos[activity][1] + element_distance * np.sin(angle_element)
            )

    return pos

# Fonction de visualisation
def visualize_star_graph(G, property_name, center_node):
    pos = custom_layout(G, center_node)
    plt.figure(figsize=(14, 12))
    node_colors = [G.nodes[node].get("color", "gray") for node in G]

    # Dessiner les nœuds et les étiquettes
    nx.draw(G, pos, with_labels=True, node_color=node_colors, font_size=8, node_size=1800)

    # Dessiner les étiquettes des arêtes avec une police plus petite
    edge_labels = nx.get_edge_attributes(G, 'label')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color="red", font_size=6)

    plt.title(f"Communauté d'activités pour la propriété '{property_name}'")
    plt.show()

# Générer et visualiser chaque graphe pour les propriétés spécifiées
for property_name in selected_properties:
    G, connections_found = create_star_graph(g, property_name)
    if connections_found:  # Vérifier qu'il y a des connexions avant de visualiser
        center_node = f"Centre-{property_name}"
        visualize_star_graph(G, property_name, center_node)
    else:
        print(f"Aucune communauté trouvée pour la propriété '{property_name}'.")

"""a modifier"""

def filter_activities_by_property(akg: Graph, property_uri: str, value: str) -> list:
    """Retourne les activités qui ont une certaine propriété avec une certaine valeur."""
    activities = []
    for activity in akg.subjects(predicate=URIRef(property_uri), object=value):
        activities.append(str(activity))
    return activities

# Exemple d'utilisation
property_uri = "http://sonfack.com/2023/12/tao/hasName"  # URI de la propriété à filtrer
value = "SomeActivityName"  # Valeur à filtrer
filtered_activities = filter_activities_by_property(graph, property_uri, value)
print(f"Activités avec {property_uri} = {value} :")
for activity in filtered_activities:
    print(activity)

# Définir les namespaces
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")
tao_namespace = Namespace("http://sonfack.com/2023/12/tao/")

# Fonction pour construire l'URL à partir du namespace et de la référence
def build_url_from_namespace(reference):
    return str(tao_namespace[reference])

# Entrée utilisateur
dt = input("Entrez la référence de votre entité : ")

# Recherche de toutes les URLs qui contiennent le mot-clé
matching_urls = [url for url in datas if dt in url]

# Afficher les résultats
if matching_urls:
    print("\nURLs trouvées contenant le mot-clé '" + dt + "' :")
    for url in matching_urls:
        print(url)
else:
    # Si aucune URL n'est trouvée avec le mot-clé, on essaie avec la référence complète
    constructed_url = build_url_from_namespace(dt)
    found_url = next((url for url in datas if url.strip() == constructed_url.strip()), None)

    if found_url:
        print("\nURL trouvée :")
        print(found_url)
    else:
        print("\nAucune URL trouvée avec cet identifiant ou ce mot-clé.")

print("\nVotre entité est : " + dt + " !")

def find_entities_by_name(name):
    matching_entities = df[df['entity_name'].str.contains(name, case=False, na=False)]
    return matching_entities

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
from rdflib import Graph, Namespace
from networkx.algorithms import community

# Initialisation du graphe RDF
graph = Graph()
graph.parse("C://Users//teaching_akg.ttl", format="ttl")

# Définir les namespaces
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")
tao_namespace = Namespace("http://sonfack.com/2023/12/tao/")

# Charger les triplets du graphe RDF dans un DataFrame
def load_graph_to_dataframe(graph):
    rows = []
    for s, p, o in graph:
        rows.append({
            'subject': s,
            'predicate': p,
            'object': o
        })
    return pd.DataFrame(rows)

# Charger les triplets RDF dans un DataFrame
df = load_graph_to_dataframe(graph)

# Nettoyer les noms pour qu'ils soient plus lisibles
def get_clean_name(uri):
    """Extrait un nom propre d'un URI pour l'affichage."""
    if '#' in uri:
        return uri.split('#')[-1]
    return uri.split('/')[-1]

# Fonction pour récupérer les informations d'une activité
def read_akg_node(node_uri, graph):
    """Récupère toutes les relations pour un nœud RDF donné."""
    node_info = {}
    for s, p, o in graph.triples((node_uri, None, None)):
        if p not in node_info:
            node_info[p] = []
        node_info[p].append(o)
    return node_info

# Fonction pour ajouter les activités et leurs relations dans NetworkX
def add_activity_to_nxgraph(G, activity_uri, activity_info):
    """Ajoute les activités et leurs relations au graphe NetworkX."""
    # Essayer de récupérer le nom (hasName)
    has_name = activity_info.get('http://sonfack.com/2023/12/tao/hasName', [None])[0]
    if has_name:
        central_node = get_clean_name(has_name)  # Utiliser le nom nettoyé
    else:
        central_node = get_clean_name(activity_uri)  # Utiliser l'URI nettoyée si hasName n'existe pas

    for pred, obj_list in activity_info.items():
        pred_label = pred.split('/')[-1]
        if '#' in pred_label:
            pred_label = pred_label.split('#')[1]

        for obj in obj_list:
            obj_label = get_clean_name(obj)  # Nettoyer également les objets
            node_info = read_akg_node(obj_label, graph)

            if node_info:
                obj_label = node_info.get('http://sonfack.com/2023/12/tao/hasName', [None])[0]
                if obj_label is None:
                    continue
                obj_label = get_clean_name(obj_label)

            G.add_node(central_node)
            G.add_node(obj_label)
            G.add_edge(central_node, obj_label, label=pred_label)

# Fonction pour rechercher des entités par nom du sujet ou de l'objet
def find_entities_by_name(name):
    try:
        # Rechercher des correspondances dans les colonnes 'subject' et 'object'
        matching_entities = df[(df['subject'].astype(str).str.contains(name, case=False, na=False)) |
                               (df['object'].astype(str).str.contains(name, case=False, na=False))]
        return matching_entities
    except KeyError:
        print("Les colonnes 'subject' ou 'object' sont introuvables dans les données. Veuillez vérifier le fichier.")
        return pd.DataFrame()  # Renvoie un DataFrame vide en cas d'erreur

# Fonction pour afficher les entités et demander une sélection par nom d'objet
def choose_entity_by_object_name(entities):
    print("\nEntités trouvées :")
    for i, row in entities.iterrows():
        print(f"{i}: URI: {row['subject']} - Objet: {row['object']}")

    # Validation de l'entrée utilisateur pour éviter les erreurs
    while True:
        try:
            choice = input("\nEntrez le nom de l'objet que vous souhaitez sélectionner: ")
            # Rechercher l'objet choisi dans les entités trouvées
            matched_entity = entities[entities['object'].astype(str).str.contains(choice, case=False, na=False)]

            if not matched_entity.empty:
                return matched_entity.iloc[0]  # Retourner la première entité trouvée
            else:
                print("Objet non trouvé, veuillez réessayer.")
        except ValueError:
            print("Entrée invalide, veuillez entrer un nom valide.")

# Fonction pour visualiser tout le graphe avec les communautés
def visualize_graph_with_communities(G, partition):
    """Visualiser tout le graphe avec les communautés détectées."""
    plt.figure(figsize=(12, 12))

    # Utiliser une palette de couleurs pour les différentes communautés
    community_colors = [f"C{community_id % 10}" for community_id in partition.values()]

    # Positionner les nœuds
    pos = nx.spring_layout(G, seed=42)  # Utiliser le même layout pour avoir une cohérence visuelle

    # Dessiner les nœuds avec les couleurs de la communauté
    nx.draw_networkx_nodes(G, pos, node_color=community_colors, node_size=300, cmap=plt.cm.Set1)

    # Dessiner les arêtes
    nx.draw_networkx_edges(G, pos, edge_color="gray", alpha=0.5)

    # Afficher les labels des nœuds
    node_labels = {node: get_clean_name(node) for node in G.nodes()}  # Utiliser les noms nettoyés
    nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=8, font_weight="bold", font_color="black")

    # Afficher les labels des arêtes
    edge_labels = nx.get_edge_attributes(G, 'label')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red', font_size=10)

    plt.title("Visualisation des communautés dans le Graphe de Connaissances")
    plt.show()

# Fonction pour détecter les communautés avec l'algorithme de Louvain
def detect_communities(G):
    """Détecte les communautés dans le graphe en utilisant l'algorithme de Louvain."""
    # Utiliser l'algorithme de Louvain pour détecter les communautés
    communities_generator = community.louvain_communities(G, seed=42)

    # Créer une partition sous forme de dictionnaire {node: community_id}
    partition = {}
    for i, comm in enumerate(communities_generator):
        for node in comm:
            partition[node] = i  # Assigner l'ID de la communauté

    return partition

# Fonction pour visualiser l'activité et détecter les communautés
def visualize_activity_with_communities(activity_uri, graph):
    """Crée un graphe NetworkX pour une activité et détecte les communautés."""
    G = nx.Graph()  # Créer un graphe vide

    # Récupérer les informations de l'activité depuis le graphe RDF
    activity_info = read_akg_node(activity_uri, graph)

    # Ajouter l'activité et ses relations dans le graphe NetworkX
    add_activity_to_nxgraph(G, activity_uri, activity_info)

    # Détecter les communautés
    partition = detect_communities(G)

    # Visualiser tout le graphe avec les communautés
    visualize_graph_with_communities(G, partition)

# Recherche des entités correspondant au nom entré dans 'subject' ou 'object'
entity_name_input = input("\nEntrez un mot pour rechercher dans les sujets ou objets : ")
matching_entities = find_entities_by_name(entity_name_input)

# Si des entités sont trouvées, permettre à l'utilisateur de choisir
if not matching_entities.empty:
    chosen_entity = choose_entity_by_object_name(matching_entities)

    # Visualiser l'activité sélectionnée et détecter les communautés
    visualize_activity_with_communities(chosen_entity['subject'], graph)
else:
    print("Aucune entité trouvée avec ce mot-clé.")

"""test2"""

from rdflib import Graph
import pandas as pd

# Charger les données RDF dans le graphe
graph = Graph()
graph.parse("C://Users//teaching_akg.ttl", format="ttl")

def find_entity_info_by_value(search_value, graph):
    """
    Chercher une entité dans le graphe RDF par son sujet, prédicat ou objet.
    :param search_value: Le mot-clé ou élément à rechercher dans le graphe.
    :param graph: Le graphe RDF où rechercher.
    :return: Liste des triplets RDF contenant la valeur recherchée.
    """
    entity_info = []

    # Parcourir tous les triplets du graphe (sujet, prédicat, objet)
    for subj, pred, obj in graph:
        # Vérifier si la valeur recherchée est présente dans le sujet, prédicat ou objet
        if search_value.lower() in str(subj).lower() or search_value.lower() in str(pred).lower() or search_value.lower() in str(obj).lower():
            entity_info.append([str(subj), str(pred), str(obj)])

    return entity_info

def display_entity_info_as_table(search_value, graph):
    """
    Afficher les informations RDF d'une entité en fonction d'un mot-clé (sujet, prédicat ou objet) sous forme de tableau.
    """
    # Récupérer les informations en fonction de la valeur recherchée
    entity_info = find_entity_info_by_value(search_value, graph)

    # Créer un DataFrame pour afficher les résultats sous forme de tableau
    if entity_info:
        df = pd.DataFrame(entity_info, columns=["Sujet", "Propriété", "Objet"])
        return df
    else:
        return pd.DataFrame([], columns=["Sujet", "Propriété", "Objet"])

# Demander à l'utilisateur d'entrer un mot-clé à rechercher
search_value = input("\nEntrez un mot pour rechercher dans les sujets, prédicats ou objets : ")

# Afficher les résultats sous forme de tableau
df_entity_info = display_entity_info_as_table(search_value, graph)

# Afficher le tableau s'il contient des données
if not df_entity_info.empty:
    print(df_entity_info.to_string(index=False))
else:
    print("Aucune entité trouvée pour le mot-clé spécifié.")

# Si vous êtes dans un environnement Jupyter/Colab, cela affichera le tableau directement :
df_entity_info  # Affichage du DataFrame dans Colab ou Jupyter



import networkx as nx
import matplotlib.pyplot as plt
import random

def modified_louvain_algorithm(G):
    # Initialisation : Chaque sommet forme sa propre communauté
    partition = {node: i for i, node in enumerate(G.nodes())}

    # Créer une liste initiale de communautés, chaque nœud est dans sa propre communauté
    initial_communities = [{v} for v in G.nodes()]
    Q = nx.algorithms.community.modularity(G, initial_communities)

    # Pour chaque sommet v, commencer la fusion
    for v in G.nodes():
        # Créer une liste triée aléatoirement des voisins de v
        L = list(G.neighbors(v))
        random.shuffle(L)

        # Pour chaque sommet voisin de v
        for n in L:
            # Initialisation de la variable de comparaison
            q_max = -float('inf')
            best_neighbor = None

            # Calculer la partition actuelle
            current_partition = [set() for _ in range(len(set(partition.values())))]
            for node, comm in partition.items():
                current_partition[comm].add(node)

            # Calculer la modularité avant la fusion
            q = nx.algorithms.community.modularity(G, current_partition)

            # Si la modularité après fusion est meilleure
            if q > q_max:
                best_neighbor = n
                q_max = q

            # Si la meilleure modularité après fusion est supérieure à Q
            if q_max > Q:
                # Fusionner les deux sommets dans la même communauté
                partition[v] = partition[best_neighbor]
                Q = q_max  # Mettre à jour la modularité courante
                break

    # Transformer le dictionnaire en liste de communautés
    communities = {}
    for node, comm in partition.items():
        if comm not in communities:
            communities[comm] = set()
        communities[comm].add(node)

    # Créer la liste des communautés
    final_partition = list(communities.values())

    # Créer un dictionnaire à partir de la partition pour que chaque nœud ait une communauté
    partition_dict = {}
    for i, community in enumerate(final_partition):
        for node in community:
            partition_dict[node] = i

    # Calculer la modularité finale avec la partition obtenue
    modularity_finale = nx.algorithms.community.modularity(G, final_partition)

    return partition_dict, modularity_finale

def visualize_graph_with_communities(G, partition):
    """Visualiser tout le graphe avec les communautés détectées."""
    plt.figure(figsize=(10, 10))

    pos = nx.spring_layout(G, seed=42)  # Positionnement des nœuds

    # Générer une palette de couleurs pour chaque communauté
    unique_communities = len(set(partition.values()))
    color_map = [plt.cm.tab20(i) for i in range(unique_communities)]

    # Affichage des arêtes
    nx.draw_networkx_edges(G, pos, alpha=0.5, edge_color='gray')

    # Dessiner les nœuds en fonction de leurs communautés
    for i, community in enumerate(set(partition.values())):
        nodes_in_community = [node for node in G.nodes() if partition[node] == community]
        nx.draw_networkx_nodes(G, pos, nodelist=nodes_in_community, node_color=[color_map[i]], node_size=300)

    # Afficher les labels des nœuds
    nx.draw_networkx_labels(G, pos, font_size=10, font_color='black')

    plt.title("Visualisation des communautés (Louvain Modifié)")
    plt.show()

# Exemple d'utilisation avec un graphe
G = nx.karate_club_graph()  # Exemple de graphe

# Appliquer l'algorithme de Louvain modifié
partition, modularity = modified_louvain_algorithm(G)

# Visualiser le graphe avec les communautés détectées
visualize_graph_with_communities(G, partition)

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt

# Générer un graphe exemple
G = nx.karate_club_graph()  # Exemple avec un graphe pré-défini, remplacez par G = (V, E) si vous avez un graphe personnalisé

# Étape 1 : Créer une matrice de dissimilarité (peut être basée sur la distance entre les nœuds, par exemple)
def create_dissimilarity_matrix(G):
    nodes = list(G.nodes())
    dissimilarity_matrix = np.zeros((len(nodes), len(nodes)))

    for i in range(len(nodes)):
        for j in range(i + 1, len(nodes)):
            try:
                dissimilarity_matrix[i][j] = nx.shortest_path_length(G, nodes[i], nodes[j])
            except nx.NetworkXNoPath:
                dissimilarity_matrix[i][j] = float('inf')  # Si pas de chemin entre i et j
            dissimilarity_matrix[j][i] = dissimilarity_matrix[i][j]

    return dissimilarity_matrix, nodes

# Étape 2 : Appliquer l'algorithme de classification ascendante hiérarchique
def simple_linkage_clustering(G):
    dissimilarity_matrix, nodes = create_dissimilarity_matrix(G)
    clusters = [[n] for n in nodes]  # Chaque nœud est initialement un cluster

    while len(clusters) > 1:
        # Trouver la paire de clusters avec la dissimilarité minimale
        min_dist = float('inf')
        to_merge = (None, None)

        for i in range(len(clusters)):
            for j in range(i + 1, len(clusters)):
                min_dissimilarity = min(
                    dissimilarity_matrix[nodes.index(a)][nodes.index(b)]
                    for a in clusters[i] for b in clusters[j]
                )
                if min_dissimilarity < min_dist:
                    min_dist = min_dissimilarity
                    to_merge = (i, j)

        # Fusionner les clusters
        if to_merge[0] is not None and to_merge[1] is not None:
            clusters[to_merge[0]] += clusters[to_merge[1]]
            del clusters[to_merge[1]]

        print(f"Fusion des clusters : {clusters}")

    return clusters

# Exécution de l'algorithme
final_clusters = simple_linkage_clustering(G)
print("Clusters finaux :", final_clusters)

# Étape 3 : Visualiser le résultat
def plot_graph(G, clusters):
    pos = nx.spring_layout(G)
    colors = ['#%06X' % np.random.randint(0, 0xFFFFFF) for _ in range(len(clusters))]

    plt.figure(figsize=(8, 6))

    for i, cluster in enumerate(clusters):
        nx.draw_networkx_nodes(G, pos, nodelist=cluster, node_color=colors[i], node_size=300)

    nx.draw_networkx_edges(G, pos, alpha=0.5)
    nx.draw_networkx_labels(G, pos)

    plt.title("Clustering par lien simple")
    plt.show()

# Visualiser les clusters
plot_graph(G, final_clusters)

from rdflib import Graph, URIRef
import pandas as pd

# Charger les données RDF dans le graphe
graph = Graph()
graph.parse("C://Users//teaching_akg.ttl", format="ttl")

def get_entity_info(entity_uri, graph):
    """
    Interroger le graphe RDF pour obtenir les informations d'une entité spécifique.
    """
    entity_info = []

    # Parcourir les triplets où l'entité est le sujet
    for pred, obj in graph.predicate_objects(subject=URIRef(entity_uri)):
        entity_info.append([str(entity_uri), str(pred), str(obj)])

    return entity_info

def display_entity_info_as_table(entity_uri, graph):
    """
    Afficher les informations RDF d'une entité sous forme de tableau.
    """
    # Récupérer les informations de l'entité
    entity_info = get_entity_info(entity_uri, graph)

    # Créer un DataFrame pour afficher les résultats sous forme de tableau
    df = pd.DataFrame(entity_info, columns=["Sujet", "Propriété", "Objet"])

    return df

# Interroger une entité spécifique
entity_uri = "http://sonfack.com/2023/12/tao/Automaton"  # Remplacez par l'URI de votre choix

# Recherche des entités correspondant au nom entré dans 'subject' ou 'object'
entity_name_input = input("\nEntrez un mot pour rechercher dans les sujets ou objets : ")
matching_entities = find_entities_by_name(entity_name_input)

# Si des entités sont trouvées, permettre à l'utilisateur de choisir
if not matching_entities.empty:
    chosen_entity = choose_entity_by_object_name(matching_entities)
df_entity_info = display_entity_info_as_table(entity_uri, graph)

# Afficher le tableau
print(df_entity_info)

# Si vous êtes dans un environnement Jupyter/Colab, cela affichera le tableau directement :
df_entity_info  # Affichage du DataFrame dans Colab ou Jupyter

import pandas as pd
from rdflib import Graph, Namespace, URIRef

# Définir les namespaces
cao_namespace = Namespace("http://sonfack.com/2023/12/cao/")
tao_namespace = Namespace("http://sonfack.com/2023/12/tao/")

# Créer un graphe RDF
G = Graph()

# Charger les données RDF dans le graphe
# Remplace "path_to_your_ttl_file.ttl" par le chemin de ton fichier TTL
G.parse("C://Users//teaching_akg.ttl", format="ttl")

def get_entity_info(entity_uri, graph):
    """
    Interroger le graphe RDF pour obtenir les informations d'une entité spécifique.
    """
    entity_info = []

    # Parcourir les triplets où l'entité est le sujet
    for pred, obj in graph.predicate_objects(subject=URIRef(entity_uri)):
        entity_info.append([entity_uri, pred, obj])

    return entity_info

def display_entity_info_as_table(entity_uri, graph):
    """
    Afficher les informations RDF d'une entité sous forme de tableau.
    """
    # Récupérer les informations de l'entité
    entity_info = get_entity_info(entity_uri, graph)

    # Créer un DataFrame pour afficher les résultats sous forme de tableau
    df = pd.DataFrame(entity_info, columns=["Sujet", "Propriété", "Objet"])

    return df

# Exemple : Interroger le système pour obtenir les informations liées à une entité spécifique
entity_uri = "http://sonfack.com/2023/12/tao/Automaton"  # Remplacer par l'URI de l'entité à interroger
df_entity_info = display_entity_info_as_table(entity_uri, G)

# Afficher le tableau sous forme textuelle dans Colab
df_entity_info  # Cette ligne affiche le DataFrame directement dans Colab

from matplotlib import pyplot as plt
import seaborn as sns
df_entity_info.groupby('Objet').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)




# Contenu de votre script projet_tpe2_1.py

# Ajoutez votre logique ici
# Exemple : du traitement de données, de l'analyse, etc.

# À la fin du script, ajoutez la ligne suivante
print("Le script a été exécuté avec succès.")

